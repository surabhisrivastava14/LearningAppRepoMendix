// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package tcconnector.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.ISession;
import com.mendix.thirdparty.org.json.JSONObject;
import com.mendix.webui.CustomJavaAction;
import tcconnector.foundation.TcConnection;
import tcconnector.foundation.exceptions.InvalidCredentialsException;
import tcconnector.internal.foundation.Constants;

/**
 * SOA URL: 
 * Core-2011-06-Session/login
 * 
 * Tc Version:
 * Teamcenter 9.0
 * 
 * Description:
 * Authenticates the user's credentials and initialize a Teamcenter session for this client. The operation will throw an InvalidCredentialsException if the username, password or group is not valid. 
 * When the client application is deployed to a 4Tier environment (communication through HTTP or TCCS) the login operation also contributes to the assignment of a Teamcenter server instance to the client session. The Teamcenter architecture varies from other client server architectures in that there is a dedicated instance of the Teamcenter server per client application. However, there are use cases where it is desirable for a single user to have multiple desktop applications running and each sharing a single instance of a Teamcenter server. This is controlled through the following elements: 
 * 
 * hostPath    From the Connection class constructor, this specifies the address (URI) the Teamcenter server is hosted on. 
 * username    From this login operation, this specifies the user's Teamcenter user name. 
 * sessionDiscriminator    From this login operation, this identifies the client session. 
 * 
 * The hostPath argument determines the server machine that the client connects to. Once there, the pool manager on that host uses the username and sessionDiscriminator arguments of the login request to determine which Teamcenter server instance to assign the client to. If the pool manager has an existing Teamcenter server instance with the username/sessionDiscriminator key, the client is assigned to that existing instance of the Teamcenter server, and therefore sharing the server with another client; otherwise, a new instance of the Teamcenter server is used. There are a few general scenarios for the sessionDiscriminator argument: 
 * 
 * Blank     If the user jdoe logs on to Teamcenter using two or more client applications using a blank sessionDiscriminator argument (for example, jdoe/ ), all of those clients are assigned to the same Teamcenter server instance. These client applications can be running on the same or different client hosts. 
 * Constant     If the user jdoe logs on to Teamcenter using two or more client applications using a constant or fixed sessionDiscriminator argument (for example, jdoe/MyApp ), those clients are assigned to the same Teamcenter server instance. This is similar to the blank sessionDiscriminator argument; the difference is that only multiple instances of the client application using myApp started by jdoe share the same Teamcenter server instance. 
 * Unique     If the user jdoe logs on using a unique random-generated string (for example, jdoe/akdk938lakc), the client application will be assigned to a dedicated instance of the Teamcenter server. 
 * 
 * The scenario you use depends on how your client application is used in the integrated environment. The most common case is the unique sessionDiscriminator value. 
 * 
 * Returns: 
 * Basic information about the server and Partial Errors are returned when the authentication is successful but requested role or locale is not supported: 
 * 
 * 214102:     The login is accepted, however the requested role is not valid, and the default role will be used. 
 * 214109:     The login is accepted, however the login group was empty so default role will be used. 
 * 128003:     The logon is accepted. However, data entry should be done using certain locales, as specified by the TC_language_data_entry preference. The details of the data entry are returned in the error message. 
 * 128004:    The logon is accepted. However, data entry should only contain characters that belong to the encoding of the database instance. The information is in the error message. 
 * Throws: 
 * InvalidCredentialsException - When the credentials supplied are invalid or the requested locale is not allowed. 
 * 
 * 515143:     The logon was refused due to invalid username or password. 
 * 515144:     The logon was refused due to invalid username or password. 
 * 515142:     The logon was refused due to an invalid group. 
 * 128001: The logon was refused due to conflict with the encoding of the database instance. 
 * 128002:    The logon was refused due to missing localization. 
 * 
 */
public class Login extends CustomJavaAction<java.lang.Boolean>
{
	private IMendixObject __UserCredentials;
	private tcconnector.proxies.Credentials UserCredentials;
	private java.lang.String ConfigurationName;

	public Login(IContext context, IMendixObject UserCredentials, java.lang.String ConfigurationName)
	{
		super(context);
		this.__UserCredentials = UserCredentials;
		this.ConfigurationName = ConfigurationName;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		this.UserCredentials = this.__UserCredentials == null ? null : tcconnector.proxies.Credentials.initialize(getContext(), __UserCredentials);

		// BEGIN USER CODE
		ISession iSession = getContext().getSession();
		boolean useSharedSession = tcconnector.proxies.constants.Constants.getUseSharedSession();
		String descriminator = (useSharedSession) ? "SharedMendix" : Integer.toString(iSession.getId().hashCode());
		String locale = iSession.getUser(getContext()).getLanguage().getCode();
		String group = UserCredentials.getgroup();
		String role = UserCredentials.getrole();

		JSONObject credentials = new JSONObject();
		credentials.put(Constants.KEY_USER, UserCredentials.getuser());
		credentials.put(Constants.KEY_PASS, UserCredentials.getpassword());
		credentials.put(Constants.KEY_GROUP, (group == null) ? "" : group);
		credentials.put(Constants.KEY_ROLE, (role == null) ? "" : role);
		credentials.put(Constants.KEY_LOCALE, locale);
		credentials.put(Constants.KEY_DESCRIMINATOR, descriminator);
		JSONObject loginArgs = new JSONObject();
		loginArgs.put(Constants.KEY_CREDENTIALS, credentials);

		JSONObject response = TcConnection.callTeamcenterService(getContext(), Constants.OPERATION_LOGIN, loginArgs,
				null, ConfigurationName);

		if (response.getString(Constants.KEY_QNAME).equals(Constants.QNAME_CREDENTIAL_EXP)) {
			throw new InvalidCredentialsException(response);
		}
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "Login";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
